<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>Messages — Hemline Market</title>

  <!-- UNIVERSAL CSS STACK -->
  <link rel="stylesheet" href="styles/hm-modern.css"/>
  <link rel="stylesheet" href="styles/hm-header.css"/>
  <link rel="stylesheet" href="styles/hm-typography.css"/>
  <link rel="stylesheet" href="styles/hm-footer.css"/>

  <style>
    :root{
      --ink:#111827;
      --muted:#6b7280;
      --line:#e5e7eb;
      --bg:#fff;
      --accent:#991b1b;
      --bg-page:#fafafa;
      --order-badge:#fef3c7;
      --order-border:#f59e0b;
    }

    html,body{
      margin:0;
      background:var(--bg-page);
      color:var(--ink);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
      -webkit-font-smoothing:antialiased;
      max-width:100%;
      overflow-x:hidden;
    }

    .wrap{
      max-width:1200px;
      margin:0 auto;
      padding:0 12px 16px;
    }

    h1{
      margin:18px 0 12px;
      font-size:24px;
      font-weight:800;
    }

    .page{
      display:grid;
      grid-template-columns:320px 1fr;
      gap:16px;
      margin:16px 0;
    }

    .panel{
      background:#fff;
      border:1px solid var(--line);
      border-radius:12px;
      overflow:hidden;
    }

    /* INBOX */
    .inbox{
      display:flex;
      flex-direction:column;
    }

    .search{
      padding:10px;
      border-bottom:1px solid var(--line);
    }

    .search input{
      width:100%;
      padding:10px;
      border:1px solid var(--line);
      border-radius:10px;
      font:inherit;
    }

    .threads{
      overflow:auto;
      max-height:calc(100vh - 220px);
    }

    .empty-state{
      padding:16px 14px;
      font-size:13px;
      color:var(--muted);
    }

    /* Thread item - collapsible */
    .thread{
      display:flex;
      flex-direction:column;
      border-top:1px solid var(--line);
      background:#fff;
      transition:background .12s ease;
    }

    .thread-header{
      display:grid;
      grid-template-columns:auto 1fr auto;
      gap:10px;
      padding:12px;
      cursor:pointer;
      transition:background .12s ease;
    }

    .thread-header:hover{ background:#f9fafb; }
    .thread.active .thread-header{ background:#fef2f2; }

    .avatar{
      width:36px;
      height:36px;
      border-radius:50%;
      background:#e5e7eb;
      display:grid;
      place-items:center;
      font-weight:700;
      font-size:14px;
    }

    .thread-main{ min-width:0; }

    .thread-name-row{
      display:flex;
      align-items:center;
      gap:6px;
    }

    .thread-name{
      font-weight:700;
      font-size:14px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    /* Order badge */
    .order-badge{
      display:inline-flex;
      align-items:center;
      gap:3px;
      font-size:10px;
      font-weight:600;
      padding:2px 6px;
      border-radius:999px;
      background:var(--order-badge);
      border:1px solid var(--order-border);
      color:#92400e;
      white-space:nowrap;
    }

    .order-badge svg{
      width:10px;
      height:10px;
    }

    .thread-preview{
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .thread-right{
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap:4px;
    }

    .pill{
      font-size:11px;
      border:1px solid var(--line);
      padding:2px 8px;
      border-radius:999px;
      white-space:nowrap;
    }

    /* Collapse/expand toggle */
    .collapse-toggle{
      display:flex;
      align-items:center;
      justify-content:center;
      width:20px;
      height:20px;
      border:none;
      background:transparent;
      color:var(--muted);
      cursor:pointer;
      transition:transform .2s ease;
      padding:0;
    }

    .collapse-toggle svg{
      width:16px;
      height:16px;
    }

    .thread.collapsed .collapse-toggle{
      transform:rotate(-90deg);
    }

    /* Thread details (collapsible content) */
    .thread-details{
      padding:0 12px 12px 58px;
      font-size:12px;
      color:var(--muted);
      display:flex;
      flex-direction:column;
      gap:4px;
      border-bottom:1px solid var(--line);
    }

    .thread.collapsed .thread-details{
      display:none;
    }

    /* Also collapse the preview text when collapsed */
    .thread.collapsed .thread-preview{
      display:none;
    }

    .thread-details a{
      color:var(--accent);
      text-decoration:none;
    }

    .thread-details a:hover{
      text-decoration:underline;
    }

    /* CHAT */
    .chat{
      display:flex;
      flex-direction:column;
      height:calc(100vh - 220px);
    }

    .chat.empty .chat-header,
    .chat.empty .chat-scroll{
      display:none;
    }

    .chat.empty .chat-empty{
      display:flex;
    }

    .chat-header{
      padding:14px 16px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      gap:10px;
      background:#fff;
    }

    .chat-header-name{ font-weight:700; font-size:14px; }
    .chat-header-meta{ font-size:12px; color:var(--muted); }

    .chat-order-info{
      display:flex;
      align-items:center;
      gap:6px;
      margin-left:8px;
      padding:4px 10px;
      background:var(--order-badge);
      border:1px solid var(--order-border);
      border-radius:8px;
      font-size:12px;
      color:#92400e;
    }

    .chat-order-info a{
      color:#92400e;
      font-weight:600;
      text-decoration:none;
    }

    .chat-order-info a:hover{
      text-decoration:underline;
    }

    .btn-delete-thread{
      margin-left:auto;
      padding:8px;
      border:1px solid var(--line);
      border-radius:8px;
      background:#fff;
      cursor:pointer;
      color:var(--muted);
    }
    .btn-delete-thread:hover{
      background:#fef2f2;
      border-color:#fecaca;
      color:#b91c1c;
    }

    .chat-empty{
      flex:1;
      align-items:center;
      justify-content:center;
      text-align:center;
      color:var(--muted);
      font-size:14px;
      padding:32px 24px;
      display:none;
    }

    .chat-scroll{
      flex:1;
      overflow:auto;
      padding:14px 16px;
      display:flex;
      flex-direction:column;
      gap:6px;
      background:#fcfcfc;
    }

    .bubble{
      display:inline-block;
      max-width:60%;
      padding:8px 10px;
      border:1px solid var(--line);
      border-radius:10px;
      background:#fff;
      font-size:13px;
      line-height:1.4;
      white-space:pre-wrap;
      word-break:break-word;
    }

    .bubble.me{
      align-self:flex-end;
      background:#fef2f2;
      border-color:#fca5a5;
    }

    .stamp{
      font-size:11px;
      color:var(--muted);
      align-self:center;
      margin-top:2px;
    }

    .composer{
      border-top:1px solid var(--line);
      padding:10px;
      display:flex;
      gap:8px;
      background:#fff;
    }

    .composer textarea{
      flex:1;
      min-height:42px;
      max-height:120px;
      padding:10px;
      border:1px solid var(--line);
      border-radius:10px;
      font:inherit;
      resize:vertical;
    }

    .composer button{
      background:var(--accent);
      color:#fff;
      border:0;
      border-radius:10px;
      padding:10px 14px;
      font-weight:700;
      cursor:pointer;
    }

    @media (max-width:900px){
      .page{ grid-template-columns:1fr; }
      .chat{ height:auto; }
      .threads{ max-height:none; }
    }
  </style>
</head>

<body>
<div id="hm-shell-header"></div>

<main class="wrap" id="maincontent">
  <h1>Messages</h1>

  <div class="page">
    <!-- LEFT: Inbox -->
    <section class="panel inbox">
      <div class="search">
        <input id="searchInput" placeholder="Search messages…"/>
      </div>
      <div class="threads" id="threadsList">
        <div class="empty-state" id="threadsEmpty">
          No conversations yet. When you message a seller or buyer, threads will appear here.
        </div>
      </div>
    </section>

    <!-- RIGHT: Chat -->
    <section class="panel chat empty" id="chatPanel">
      <div class="chat-header">
        <div class="avatar" id="chatAvatar">?</div>
        <div class="chat-header-main">
          <div class="chat-header-name" id="chatName">Select a conversation</div>
          <div class="chat-header-meta" id="chatMeta">Choose a thread on the left to view messages.</div>
        </div>
        <div class="chat-order-info" id="chatOrderInfo" style="display:none;">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path>
            <line x1="3" y1="6" x2="21" y2="6"></line>
            <path d="M16 10a4 4 0 0 1-8 0"></path>
          </svg>
          <span>Order: </span>
          <a href="#" id="chatOrderLink">View Order</a>
        </div>
        <button id="deleteThreadBtn" class="btn-delete-thread" style="display:none;" title="Delete conversation">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
          </svg>
        </button>
      </div>

      <div class="chat-empty">
        <div>
          <div style="font-weight:600;margin-bottom:4px;">Select a conversation</div>
          <div>Choose a thread on the left to view messages.</div>
        </div>
      </div>

      <div class="chat-scroll" id="chatScroll"></div>

      <div class="composer">
        <textarea id="msgInput" placeholder="Write a reply…"></textarea>
        <button id="sendBtn" disabled>Send</button>
      </div>
    </section>
  </div>
</main>

<div id="hm-shell-footer"></div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="scripts/hm-shell.js"></script>

<script>
/* ===========================================================
   SUPABASE CLIENT
=========================================================== */
const supabaseClient = window.supabase.createClient(
  "https://clkizksbvxjkoatdajgd.supabase.co",
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNsa2l6a3Nidnhqa29hdGRhamdkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ2ODAyMDUsImV4cCI6MjA3MDI1NjIwNX0.m3wd6UAuqxa7BpcQof9mmzd8zdsmadwGDO0x7-nyBjI",
  { auth:{ persistSession:true, autoRefreshToken:true, detectSessionInUrl:true } }
);

/* ===========================================================
   UTILITIES
=========================================================== */
function initialsFromName(first, last, fallback){
  if(first && last) return (first[0]+last[0]).toUpperCase();
  if(first) return (first[0]+(first[1]||"")).toUpperCase();
  if(fallback) return fallback[0].toUpperCase();
  return "?";
}

function shortTimeLabel(iso){
  if(!iso) return "";
  const d = new Date(iso);
  const today = new Date();
  if(d.toDateString() === today.toDateString())
    return d.toLocaleTimeString([],{hour:"numeric",minute:"2-digit"});
  const diffDays = Math.floor((today - d)/86400000);
  if(diffDays === 1) return "Yesterday";
  if(diffDays < 7) return d.toLocaleDateString([],{weekday:"short"});
  return d.toLocaleDateString();
}

function formatStamp(iso){
  if(!iso) return "";
  const d = new Date(iso);
  return d.toLocaleString([],{month:"short",day:"numeric",hour:"numeric",minute:"2-digit"});
}

async function ensureSession(ms=3000){
  let { data:{ session } } = await supabaseClient.auth.getSession();
  if(session?.user) return session;
  const start = Date.now();
  while(!session?.user && Date.now()-start < ms){
    await new Promise(r=>setTimeout(r,130));
    ({ data:{ session } } = await supabaseClient.auth.getSession());
  }
  return session;
}

/* ===========================================================
   DOM
=========================================================== */
const threadsListEl = document.getElementById("threadsList");
const threadsEmptyEl = document.getElementById("threadsEmpty");
const searchInputEl  = document.getElementById("searchInput");

const chatPanelEl  = document.getElementById("chatPanel");
const chatAvatarEl = document.getElementById("chatAvatar");
const chatNameEl   = document.getElementById("chatName");
const chatMetaEl   = document.getElementById("chatMeta");
const chatScrollEl = document.getElementById("chatScroll");
const chatOrderInfoEl = document.getElementById("chatOrderInfo");
const chatOrderLinkEl = document.getElementById("chatOrderLink");
const msgInputEl   = document.getElementById("msgInput");
const sendBtnEl    = document.getElementById("sendBtn");

/* ===========================================================
   GLOBALS
=========================================================== */
let currentUser = null;
let currentProfile = null;
let currentThreadId = null;
let currentOtherUserId = null;
let currentOtherName = "";
let allThreads = [];
let collapsedThreads = new Set(); // Track collapsed threads

/* ===========================================================
   PROFILE
=========================================================== */
async function loadCurrentProfile(){
  const { data } = await supabaseClient
    .from("profiles")
    .select("id, first_name, last_name, store_name, email")
    .eq("id", currentUser.id)
    .maybeSingle();
  currentProfile = data;
}

function senderDisplayName(){
  if(currentProfile){
    const full = `${currentProfile.first_name||""} ${currentProfile.last_name||""}`.trim();
    if(full) return full;
    if(currentProfile.store_name) return currentProfile.store_name;
    if(currentProfile.email) return currentProfile.email;
  }
  return currentUser.email || "Hemline member";
}

/* ===========================================================
   INIT
=========================================================== */
async function initMessagesPage(){
  const session = await ensureSession();
  if(!session?.user){
    window.location.href = "auth.html";
    return;
  }
  currentUser = session.user;
  await loadCurrentProfile();

  const params = new URLSearchParams(window.location.search);

  const threadParam = params.get("thread");
  const toUserId = params.get("to") || params.get("user") || null;
  const orderIdParam = params.get("order") || null;

  let initialThreadId = null;

  if(threadParam){
    initialThreadId = threadParam;

  } else if(toUserId && toUserId !== currentUser.id){
    initialThreadId = await getOrCreateThread(
      currentUser.id,
      toUserId,
      orderIdParam
    );
  }

  await loadThreads(initialThreadId);

  sendBtnEl.disabled = false;
  sendBtnEl.addEventListener("click", handleSend);
  msgInputEl.addEventListener("keydown", e=>{
    if(e.key === "Enter" && !e.shiftKey){
      e.preventDefault();
      handleSend();
    }
  });

  searchInputEl.addEventListener("input", applyThreadFilter);
  
  // Delete thread handler
  const deleteBtn = document.getElementById("deleteThreadBtn");
  if(deleteBtn){
    deleteBtn.addEventListener("click", async ()=>{
      if(!currentThreadId) return;
      
      const confirmed = window.confirm("Delete this conversation? This will hide it from your inbox but the other person can still see it.");
      if(!confirmed) return;
      
      try{
        // Get the thread to determine which user column to update
        const thread = allThreads.find(t => t.id === currentThreadId);
        if(!thread) return;
        
        // Soft delete - mark as hidden for this user only
        const isUserA = thread.user_a === currentUser.id;
        const updateField = isUserA ? "hidden_for_user_a" : "hidden_for_user_b";
        
        await supabaseClient
          .from("message_threads")
          .update({ [updateField]: true })
          .eq("id", currentThreadId);
        
        makeChatEmpty();
        await loadThreads(null);
      }catch(e){
        console.error("Failed to delete thread", e);
        alert("Could not delete conversation. Please try again.");
      }
    });
  }
}

/* ===========================================================
   THREAD CREATION (supports order)
=========================================================== */
async function getOrCreateThread(userId, otherUserId, orderId=null){
  // If we have an order ID, look for a thread specifically for this order
  if(orderId){
    const { data:orderThread } = await supabaseClient
      .from("message_threads")
      .select("*")
      .eq("order_id", orderId)
      .maybeSingle();
    
    if(orderThread?.id){
      return orderThread.id;
    }
    
    // Create new thread for this order
    const { data:created } = await supabaseClient
      .from("message_threads")
      .insert({
        user_a: userId,
        user_b: otherUserId,
        order_id: orderId,
        last_message_at: null,
        last_message_preview: null
      })
      .select("*")
      .single();
    
    return created?.id || null;
  }
  
  // No order - look for a general thread between these users (without an order)
  const { data:existing } = await supabaseClient
    .from("message_threads")
    .select("*")
    .or(
      `and(user_a.eq.${userId},user_b.eq.${otherUserId}),` +
      `and(user_a.eq.${otherUserId},user_b.eq.${userId})`
    )
    .is("order_id", null)
    .limit(1)
    .maybeSingle();

  if(existing?.id){
    return existing.id;
  }

  // Create new general thread (no order)
  const { data:created } = await supabaseClient
    .from("message_threads")
    .insert({
      user_a: userId,
      user_b: otherUserId,
      order_id: null,
      last_message_at: null,
      last_message_preview: null
    })
    .select("*")
    .single();

  return created?.id || null;
}

/* ===========================================================
   LOAD THREAD LIST
=========================================================== */
async function loadThreads(preselectThreadId){
  const uid = currentUser.id;

  const { data } = await supabaseClient
    .from("message_threads")
    .select("*")
    .or(`user_a.eq.${uid},user_b.eq.${uid}`)
    .order("last_message_at",{ascending:false,nullsLast:true})
    .order("created_at",{ascending:false});

  // Filter out threads hidden by this user (soft delete)
  allThreads = (data || []).filter(t => {
    if(t.user_a === uid && t.hidden_for_user_a) return false;
    if(t.user_b === uid && t.hidden_for_user_b) return false;
    return true;
  });

  if(!allThreads.length){
    threadsEmptyEl.style.display = "block";
    threadsListEl.innerHTML = "";
    makeChatEmpty();
    return;
  }

  threadsEmptyEl.style.display = "none";
  threadsListEl.innerHTML = "";

  const otherIds = [];
  const orderIds = [];
  allThreads.forEach(t=>{
    const other = (t.user_a===uid ? t.user_b : t.user_a);
    if(other && !otherIds.includes(other)) otherIds.push(other);
    if(t.order_id && !orderIds.includes(t.order_id)) orderIds.push(t.order_id);
  });

  let profilesById = {};
  if(otherIds.length){
    const { data:prof } = await supabaseClient
      .from("profiles")
      .select("id, first_name, last_name, store_name, email, avatar_url")
      .in("id", otherIds);
    profilesById = Object.fromEntries((prof||[]).map(p=>[p.id,p]));
  }

  // Load order info if we have order IDs
  let ordersById = {};
  if(orderIds.length){
    const { data:orders } = await supabaseClient
      .from("orders")
      .select("id, created_at, status, item_title, listing_title")
      .in("id", orderIds);
    ordersById = Object.fromEntries((orders||[]).map(o=>[o.id,o]));
  }

  allThreads.forEach(thread=>{
    const otherId = (thread.user_a===uid ? thread.user_b : thread.user_a);
    const prof = profilesById[otherId] || {};
    const first = prof.first_name || "";
    const last  = prof.last_name  || "";
    const displayName = (first||last) ? `${first} ${last}`.trim() : prof.store_name || "Hemline member";
    const initials = initialsFromName(first,last,displayName);
    const profilePhoto = prof.avatar_url || null;
    
    // Avatar HTML - use photo if available, otherwise initials
    const avatarHtml = profilePhoto 
      ? `<img src="${profilePhoto}" alt="${displayName}" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`
      : initials;
    
    const hasOrder = !!thread.order_id;
    const order = hasOrder ? ordersById[thread.order_id] : null;
    
    // Default order threads to collapsed (details hidden), track expanded ones
    let isCollapsed = false;
    if(hasOrder){
      // For order threads: collapsed by default unless user explicitly expanded
      const expandedKey = thread.id + "_expanded";
      if(!collapsedThreads.has(expandedKey)){
        isCollapsed = true;
      }
    } else {
      isCollapsed = collapsedThreads.has(thread.id);
    }

    const row = document.createElement("div");
    row.className = "thread" + (isCollapsed ? " collapsed" : "");
    row.dataset.threadId = thread.id;
    row.dataset.otherUserId = otherId;
    row.dataset.otherName = displayName;
    row.dataset.orderId = thread.order_id || "";

    // Build order badge HTML with order ID
    let orderBadgeHtml = "";
    if(hasOrder){
      const orderShort = thread.order_id ? thread.order_id.slice(0,8) : "";
      orderBadgeHtml = `
        <span class="order-badge">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path>
            <line x1="3" y1="6" x2="21" y2="6"></line>
            <path d="M16 10a4 4 0 0 1-8 0"></path>
          </svg>
          #${orderShort}
        </span>
      `;
    }

    // Build thread details (order info)
    let detailsHtml = "";
    if(hasOrder && order){
      const orderDate = order.created_at ? new Date(order.created_at).toLocaleDateString() : "";
      const itemTitle = order.item_title || order.listing_title || "Item";
      detailsHtml = `
        <div class="thread-details">
          <div><strong>Order #${thread.order_id?.slice(0,8) || ""}</strong></div>
          <div>${itemTitle}</div>
          <div>Status: ${order.status || "Processing"}</div>
          ${orderDate ? `<div>Placed: ${orderDate}</div>` : ""}
          <a href="order-buyer.html?id=${thread.order_id}">View order details →</a>
        </div>
      `;
    }

    row.innerHTML = `
      <div class="thread-header">
        <div class="avatar">${avatarHtml}</div>
        <div class="thread-main">
          <div class="thread-name-row">
            <span class="thread-name">${displayName}</span>
            ${orderBadgeHtml}
          </div>
          <div class="thread-preview">${thread.last_message_preview||"(No messages yet)"}</div>
        </div>
        <div class="thread-right">
          <div class="pill">${shortTimeLabel(thread.last_message_at || thread.created_at)}</div>
          <button class="collapse-toggle" type="button" title="Toggle details">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
          </button>
        </div>
      </div>
      ${detailsHtml}
    `;

    // Click on header to open thread
    const header = row.querySelector(".thread-header");
    header.addEventListener("click", (e)=>{
      // Don't open if clicking collapse toggle
      if(e.target.closest(".collapse-toggle")) return;
      openThread(thread.id, otherId, displayName, initials, thread.order_id, profilePhoto);
    });

    // Collapse toggle
    const collapseBtn = row.querySelector(".collapse-toggle");
    if(collapseBtn){
      collapseBtn.addEventListener("click", (e)=>{
        e.preventDefault();
        e.stopPropagation();
        row.classList.toggle("collapsed");
      });
    }

    threadsListEl.appendChild(row);
  });

  if(preselectThreadId){
    const target = allThreads.find(t=>t.id === preselectThreadId);
    if(target){
      const otherId = (target.user_a===uid ? target.user_b : target.user_a);
      const prof = profilesById[otherId] || {};
      const displayName = `${prof.first_name||""} ${prof.last_name||""}`.trim() || prof.store_name || "Hemline member";
      const initials = initialsFromName(prof.first_name, prof.last_name, displayName);
      const photo = prof.avatar_url || null;
      openThread(target.id, otherId, displayName, initials, target.order_id, photo);
      return;
    }
  }

  makeChatEmpty();
}

/* ===========================================================
   OPEN THREAD
=========================================================== */
function makeChatEmpty(){
  currentThreadId = null;
  currentOtherUserId = null;
  currentOtherName = "";
  chatPanelEl.classList.add("empty");
  chatScrollEl.innerHTML = "";
  chatNameEl.textContent = "Select a conversation";
  chatMetaEl.textContent = "Choose a thread on the left to view messages.";
  chatAvatarEl.textContent = "?";
  
  // Hide delete button and order info when no thread selected
  const deleteBtn = document.getElementById("deleteThreadBtn");
  if(deleteBtn) deleteBtn.style.display = "none";
  if(chatOrderInfoEl) chatOrderInfoEl.style.display = "none";
}

async function openThread(threadId, otherUserId, name, initials, orderId, profilePhoto){
  currentThreadId = threadId;
  currentOtherUserId = otherUserId;
  currentOtherName = name;

  threadsListEl.querySelectorAll(".thread")
    .forEach(el=>el.classList.toggle("active", el.dataset.threadId===String(threadId)));

  chatPanelEl.classList.remove("empty");
  
  // Set avatar - use photo if available, otherwise initials
  if(profilePhoto){
    chatAvatarEl.innerHTML = `<img src="${profilePhoto}" alt="${name}" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`;
  } else {
    chatAvatarEl.innerHTML = '';
    chatAvatarEl.textContent = initials;
  }
  
  chatNameEl.textContent = name;
  chatMetaEl.textContent = "";
  
  // Show delete button when thread is selected
  const deleteBtn = document.getElementById("deleteThreadBtn");
  if(deleteBtn) deleteBtn.style.display = "block";

  // Show order info if this is an order-related conversation
  if(orderId && chatOrderInfoEl && chatOrderLinkEl){
    chatOrderInfoEl.style.display = "flex";
    chatOrderLinkEl.href = `order.html?id=${orderId}`;
  } else if(chatOrderInfoEl){
    chatOrderInfoEl.style.display = "none";
  }

  const { data } = await supabaseClient
    .from("messages")
    .select("*")
    .eq("thread_id", threadId)
    .order("created_at",{ascending:true});

  chatScrollEl.innerHTML = "";

  if(!data.length){
    const stamp = document.createElement("div");
    stamp.className = "stamp";
    stamp.textContent = "No messages yet. Send the first message.";
    chatScrollEl.appendChild(stamp);
    return;
  }

  let lastStamp = "";
  data.forEach(msg=>{
    const bubble = document.createElement("div");
    bubble.className = "bubble" + (msg.sender_id===currentUser.id ? " me" : "");
    bubble.textContent = msg.body;
    chatScrollEl.appendChild(bubble);

    const ts = formatStamp(msg.created_at);
    if(ts !== lastStamp){
      const stamp = document.createElement("div");
      stamp.className = "stamp";
      stamp.textContent = ts;
      chatScrollEl.appendChild(stamp);
      lastStamp = ts;
    }
  });

  chatScrollEl.scrollTop = chatScrollEl.scrollHeight;
}

/* ===========================================================
   SEND MESSAGE
=========================================================== */
async function handleSend(){
  const text = msgInputEl.value.trim();
  if(!text || !currentThreadId) return;

  sendBtnEl.disabled = true;

  const { data:inserted } = await supabaseClient
    .from("messages")
    .insert({
      thread_id: currentThreadId,
      sender_id: currentUser.id,
      body: text
    })
    .select("*")
    .single();

  // append bubble
  const b = document.createElement("div");
  b.className = "bubble me";
  b.textContent = text;
  chatScrollEl.appendChild(b);

  const s = document.createElement("div");
  s.className = "stamp";
  s.textContent = formatStamp(inserted.created_at);
  chatScrollEl.appendChild(s);

  chatScrollEl.scrollTop = chatScrollEl.scrollHeight;
  msgInputEl.value = "";

  const preview = text.length>140 ? text.slice(0,137)+"…" : text;

  await supabaseClient
    .from("message_threads")
    .update({
      last_message_at: inserted.created_at,
      last_message_preview: preview
    })
    .eq("id", currentThreadId);

  // notification
  if(currentOtherUserId && currentOtherUserId !== currentUser.id){
    await supabaseClient.from("notifications").insert({
      user_id: currentOtherUserId,
      type: "message",
      kind: "message",
      title: "New message from " + senderDisplayName(),
      body: preview,
      href: `messages.html?thread=${currentThreadId}`,
      link: `messages.html?thread=${currentThreadId}`,
      message_thread_id: currentThreadId,
      message_id: inserted.id
    });
  }

  sendBtnEl.disabled = false;
  loadThreads(currentThreadId);
}

function applyThreadFilter(){
  const q = searchInputEl.value.toLowerCase().trim();
  let visible = 0;

  threadsListEl.querySelectorAll(".thread").forEach(row=>{
    const name = row.dataset.otherName.toLowerCase();
    const preview = row.querySelector(".thread-preview").textContent.toLowerCase();
    const hasOrder = row.dataset.orderId ? "order" : "";
    const show = !q || name.includes(q) || preview.includes(q) || hasOrder.includes(q);
    row.style.display = show ? "flex" : "none";
    if(show) visible++;
  });

  threadsEmptyEl.style.display = visible? "none":"block";
  threadsEmptyEl.textContent = visible
    ? "No conversations yet. When you message a seller or buyer, threads will appear here."
    : "No conversations match your search.";
}

initMessagesPage();
</script>

<script>
  window.HM && window.HM.renderShell({ currentPage:"messages" });
</script>

</body>
</html>
