<!-- "messages.html" -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>Messages — Hemline Market</title>

  <!-- UNIVERSAL CSS STACK -->
  <link rel="stylesheet" href="styles/hm-modern.css"/>
  <link rel="stylesheet" href="styles/hm-header.css"/>
  <link rel="stylesheet" href="styles/hm-typography.css"/>
  <link rel="stylesheet" href="styles/hm-footer.css"/>

  <!-- Page-specific styles only -->
  <style>
    :root{
      --ink:#111827;
      --muted:#6b7280;
      --line:#e5e7eb;
      --bg:#fff;
      --accent:#991b1b;
      --bg-page:#fafafa;
    }

    html,body{
      margin:0;
      background:var(--bg-page);
      color:var(--ink);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
      -webkit-font-smoothing:antialiased;
      max-width:100%;
      overflow-x:hidden;
    }

    .wrap{
      max-width:1200px;
      margin:0 auto;
      padding:0 12px;
    }

    /* page */
    h1{
      margin:18px 0 12px;
      font-size:24px;
      font-weight:800;
    }

    .page{
      display:grid;
      grid-template-columns:320px 1fr;
      gap:16px;
      margin:16px 0;
    }

    .panel{
      background:#fff;
      border:1px solid var(--line);
      border-radius:12px;
      overflow:hidden;
    }

    .inbox{
      display:flex;
      flex-direction:column;
    }

    .search{
      padding:10px;
      border-bottom:1px solid var(--line);
    }

    .search input{
      width:100%;
      padding:10px;
      border:1px solid var(--line);
      border-radius:10px;
      font:inherit;
    }

    .threads{
      overflow:auto;
      max-height:calc(100vh - 220px);
    }

    .threads-empty{
      padding:14px;
      font-size:13px;
      color:var(--muted);
    }

    .thread{
      display:grid;
      grid-template-columns:auto 1fr auto;
      gap:10px;
      padding:12px;
      border-top:1px solid var(--line);
      cursor:pointer;
      background:#fff;
    }

    .thread:first-child{
      border-top:0;
    }

    .thread.active{
      background:#fef2f2;
    }

    .avatar{
      width:36px;
      height:36px;
      border-radius:50%;
      background:#eee;
      display:grid;
      place-items:center;
      font-weight:700;
      font-size:14px;
    }

    .meta{
      font-size:12px;
      color:var(--muted);
    }

    .title{
      font-weight:700;
    }

    .pill{
      font-size:12px;
      border:1px solid var(--line);
      padding:2px 8px;
      border-radius:999px;
      color:#374151;
      align-self:flex-start;
      white-space:nowrap;
    }

    .pill.red{
      border-color:#fca5a5;
      color:#991b1b;
    }

    .chat{
      display:flex;
      flex-direction:column;
      height:calc(100vh - 220px);
    }

    .chat-header{
      padding:14px 16px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      gap:10px;
    }

    .chat-scroll{
      flex:1;
      overflow:auto;
      padding:12px 16px;
      display:grid;
      gap:10px;
      background:#fcfcfc;
    }

    .bubble{
      max-width:70%;
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:12px;
      background:#fff;
    }

    .bubble.me{
      justify-self:end;
      background:#fef2f2;
      border-color:#fca5a5;
    }

    .stamp{
      font-size:12px;
      color:var(--muted);
      justify-self:center;
    }

    .composer{
      border-top:1px solid var(--line);
      padding:10px;
      display:flex;
      gap:8px;
      background:#fff;
    }

    .composer textarea{
      flex:1;
      min-height:42px;
      max-height:120px;
      padding:10px;
      border:1px solid var(--line);
      border-radius:10px;
      resize:vertical;
      font:inherit;
    }

    .composer button{
      background:var(--accent);
      color:#fff;
      border:0;
      border-radius:10px;
      padding:10px 14px;
      font-weight:700;
      cursor:pointer;
      font:inherit;
      white-space:nowrap;
    }

    .composer button:disabled{
      opacity:.4;
      cursor:default;
    }

    @media (max-width:900px){
      .page{
        grid-template-columns:1fr;
      }
      .chat{
        height:auto;
      }
      .threads{
        max-height:none;
      }
    }
  </style>
</head>
<body>

<!-- UNIVERSAL HEADER -->
<div id="hm-shell-header"></div>

<!-- MAIN -->
<main class="wrap" id="maincontent">
  <h1>Messages</h1>

  <div class="page">
    <!-- Inbox -->
    <section class="panel inbox" aria-label="Inbox">
      <div class="search">
        <input id="searchInput" placeholder="Search messages…"/>
      </div>
      <div class="threads" id="threadList" aria-live="polite">
        <div class="threads-empty" id="threadsEmpty">
          No messages yet. When you contact a seller or buyer, conversations will appear here.
        </div>
      </div>
    </section>

    <!-- Chat -->
    <section class="panel chat" aria-label="Conversation">
      <div class="chat-header" id="chatHeader">
        <div class="avatar" id="chatAvatar">?</div>
        <div>
          <div id="chatTitle" style="font-weight:700">Select a conversation</div>
          <div class="meta" id="chatMeta">Choose a thread on the left to view messages.</div>
        </div>
      </div>
      <div class="chat-scroll" id="chat">
        <!-- messages injected here -->
      </div>
      <div class="composer">
        <textarea id="msg" placeholder="Write a reply…" disabled></textarea>
        <button id="send" disabled>Send</button>
      </div>
    </section>
  </div>
</main>

<!-- UNIVERSAL FOOTER -->
<div id="hm-shell-footer"></div>

<!-- JS STACK -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="scripts/hm-shell.js"></script>

<script>
  // Supabase client
  const supabaseClient = window.supabase.createClient(
    "https://clkizksbvxjkoatdajgd.supabase.co",
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNsa2l6a3Nidnhqa29hdGRhamdkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ2ODAyMDUsImV4cCI6MjA3MDI1NjIwNX0.m3wd6UAuqxa7BpcQof9mmzd8zdsmadwGDO0x7-nyBjI"
  );

  let currentUser = null;
  let threadsState = [];
  let profilesCache = {};
  let activeThreadId = null;

  function initialsFromProfile(p, fallbackEmail){
    const first = p?.first_name || "";
    const last  = p?.last_name  || "";
    if(first && last) return (first[0] + last[0]).toUpperCase();
    if(first) return (first[0] + (first[1] || "")).toUpperCase();
    if(fallbackEmail) return fallbackEmail[0].toUpperCase();
    return "HM";
  }

  function fullNameFromProfile(p, fallbackEmail){
    if(!p) return fallbackEmail ? fallbackEmail.split("@")[0] : "Hemline member";
    const name = ((p.first_name || "") + " " + (p.last_name || "")).trim();
    if(name) return name;
    if(p.store_name) return p.store_name;
    if(p.email) return p.email.split("@")[0];
    return fallbackEmail ? fallbackEmail.split("@")[0] : "Hemline member";
  }

  function niceStamp(iso){
    if(!iso) return "";
    const d = new Date(iso);
    if(Number.isNaN(d.getTime())) return "";
    const now = new Date();
    const sameDay = d.toDateString() === now.toDateString();
    const yest = new Date(now);
    yest.setDate(now.getDate() - 1);
    const sameYest = d.toDateString() === yest.toDateString();
    if(sameDay) return "Today";
    if(sameYest) return "Yesterday";
    const diffMs = now - d;
    const diffDays = diffMs / (1000*60*60*24);
    if(diffDays < 7){
      return d.toLocaleDateString(undefined,{ weekday:"short" });
    }
    return d.toLocaleDateString();
  }

  async function ensureSession(maxWaitMs = 3000){
    let { data:{ session } } = await supabaseClient.auth.getSession();
    if(session?.user) return session;
    const start = Date.now();
    while(!session?.user && Date.now() - start < maxWaitMs){
      await new Promise(r => setTimeout(r,120));
      ({ data:{ session } } = await supabaseClient.auth.getSession());
    }
    return session || null;
  }

  function getOtherUserId(thread){
    if(!thread || !currentUser) return null;
    return thread.buyer_id === currentUser.id ? thread.seller_id : thread.buyer_id;
  }

  async function loadProfilesForThreads(threads){
    const ids = new Set();
    threads.forEach(t=>{
      const otherId = getOtherUserId(t);
      if(otherId && !profilesCache[otherId]) ids.add(otherId);
    });
    if(!ids.size) return;
    const { data, error } = await supabaseClient
      .from("profiles")
      .select("id, first_name, last_name, store_name, email")
      .in("id", Array.from(ids));
    if(error){
      console.error("profiles load error", error);
      return;
    }
    data.forEach(p=>{ profilesCache[p.id] = p; });
  }

  function renderThreads(){
    const listEl   = document.getElementById("threadList");
    const emptyEl  = document.getElementById("threadsEmpty");
    const searchEl = document.getElementById("searchInput");
    if(!listEl) return;

    listEl.innerHTML = "";
    if(emptyEl){
      emptyEl.style.display = threadsState.length ? "none" : "block";
      listEl.appendChild(emptyEl);
    }

    const query = (searchEl?.value || "").toLowerCase();

    const filtered = threadsState.filter(t=>{
      const otherId = getOtherUserId(t);
      const p = profilesCache[otherId] || {};
      const name = fullNameFromProfile(p,"").toLowerCase();
      const last = (t.last_message_text || "").toLowerCase();
      if(!query) return true;
      return name.includes(query) || last.includes(query);
    });

    if(!filtered.length && emptyEl){
      emptyEl.textContent = "No conversations match your search.";
      emptyEl.style.display = "block";
      return;
    }

    filtered.forEach(t=>{
      const otherId = getOtherUserId(t);
      const p = profilesCache[otherId] || {};
      const threadEl = document.createElement("div");
      threadEl.className = "thread" + (t.id === activeThreadId ? " active" : "");
      threadEl.tabIndex = 0;
      threadEl.dataset.id = t.id;

      const av = document.createElement("div");
      av.className = "avatar";
      av.textContent = initialsFromProfile(p, p.email || "");

      const mid = document.createElement("div");
      const title = document.createElement("div");
      title.className = "title";
      title.textContent = fullNameFromProfile(p, p.email || "");
      const meta = document.createElement("div");
      meta.className = "meta";
      meta.textContent = t.last_message_text || "(No messages yet)";
      mid.appendChild(title);
      mid.appendChild(meta);

      const pill = document.createElement("div");
      pill.className = "pill";
      const stamp = niceStamp(t.last_message_at || t.created_at);
      pill.textContent = stamp || "";

      threadEl.appendChild(av);
      threadEl.appendChild(mid);
      threadEl.appendChild(pill);

      threadEl.addEventListener("click", ()=> openThread(t.id));
      threadEl.addEventListener("keydown", e=>{
        if(e.key==="Enter" || e.key===" "){
          e.preventDefault();
          openThread(t.id);
        }
      });

      listEl.appendChild(threadEl);
    });
  }

  function renderChatHeader(thread){
    const headerAvatar = document.getElementById("chatAvatar");
    const headerTitle  = document.getElementById("chatTitle");
    const headerMeta   = document.getElementById("chatMeta");
    if(!headerAvatar || !headerTitle || !headerMeta) return;

    if(!thread){
      headerAvatar.textContent = "?";
      headerTitle.textContent  = "Select a conversation";
      headerMeta.textContent   = "Choose a thread on the left to view messages.";
      return;
    }

    const otherId = getOtherUserId(thread);
    const p = profilesCache[otherId] || {};
    headerAvatar.textContent = initialsFromProfile(p, p.email || "");
    headerTitle.textContent  = fullNameFromProfile(p, p.email || "");
    const stamp = niceStamp(thread.last_message_at || thread.created_at);
    headerMeta.textContent   = stamp ? ("Updated " + stamp) : "";
  }

  async function loadMessages(threadId){
    const chatEl = document.getElementById("chat");
    const msgInput = document.getElementById("msg");
    const sendBtn  = document.getElementById("send");
    if(!chatEl || !threadId) return;

    chatEl.innerHTML = "";
    const { data, error } = await supabaseClient
      .from("messages")
      .select("*")
      .eq("thread_id", threadId)
      .order("created_at",{ ascending:true });
    if(error){
      console.error("messages load error", error);
      const err = document.createElement("div");
      err.className = "stamp";
      err.textContent = "We couldn’t load messages. Please refresh.";
      chatEl.appendChild(err);
      msgInput.disabled = true;
      sendBtn.disabled = true;
      return;
    }

    if(!data.length){
      const empty = document.createElement("div");
      empty.className = "stamp";
      empty.textContent = "No messages yet. Send the first message.";
      chatEl.appendChild(empty);
    }else{
      data.forEach(m=>{
        const b = document.createElement("div");
        b.className = "bubble" + (m.sender_id === currentUser.id ? " me" : "");
        b.textContent = m.body || "";
        chatEl.appendChild(b);
      });
      const stamp = document.createElement("div");
      stamp.className = "stamp";
      const last = data[data.length-1];
      stamp.textContent = niceStamp(last.created_at);
      chatEl.appendChild(stamp);
    }

    chatEl.scrollTop = chatEl.scrollHeight;
    msgInput.disabled = false;
    sendBtn.disabled  = false;
  }

  async function openThread(threadId){
    activeThreadId = threadId;
    const thread = threadsState.find(t => t.id === threadId) || null;
    renderThreads();
    renderChatHeader(thread);
    await loadMessages(threadId);
  }

  async function sendMessage(){
    const input = document.getElementById("msg");
    const chatEl = document.getElementById("chat");
    if(!input || !chatEl || !activeThreadId || !currentUser) return;

    const text = input.value.trim();
    if(!text) return;

    const body = { thread_id: activeThreadId, sender_id: currentUser.id, body: text };
    input.value = "";
    input.disabled = true;

    const { data, error } = await supabaseClient
      .from("messages")
      .insert(body)
      .select()
      .single();

    if(error){
      console.error("send message error", error);
      input.disabled = false;
      return;
    }

    // Optimistic append
    const b = document.createElement("div");
    b.className = "bubble me";
    b.textContent = data.body || text;
    chatEl.appendChild(b);
    const stamp = document.createElement("div");
    stamp.className = "stamp";
    stamp.textContent = niceStamp(data.created_at);
    chatEl.appendChild(stamp);
    chatEl.scrollTop = chatEl.scrollHeight;

    // Update thread metadata in state
    const idx = threadsState.findIndex(t=>t.id === activeThreadId);
    if(idx !== -1){
      threadsState[idx].last_message_text = data.body || text;
      threadsState[idx].last_message_at   = data.created_at;
    }
    renderThreads();
    input.disabled = false;

    // Persist latest meta on thread (best-effort)
    try{
      await supabaseClient
        .from("threads")
        .update({
          last_message_text: data.body || text,
          last_message_at: data.created_at
        })
        .eq("id", activeThreadId);
    }catch(e){
      console.warn("thread meta update failed", e);
    }
  }

  async function loadThreads({ focusThreadId } = {}){
    if(!currentUser) return;

    const { data, error } = await supabaseClient
      .from("threads")
      .select("*")
      .or(`buyer_id.eq.${currentUser.id},seller_id.eq.${currentUser.id}`)
      .order("last_message_at",{ ascending:false, nullsLast:true });

    if(error){
      console.error("threads load error", error);
      const listEl = document.getElementById("threadList");
      const emptyEl = document.getElementById("threadsEmpty");
      if(emptyEl){
        emptyEl.textContent = "We couldn’t load your conversations. Please refresh.";
        emptyEl.style.display = "block";
      }else if(listEl){
        listEl.textContent = "We couldn’t load your conversations.";
      }
      return;
    }

    threadsState = data || [];
    await loadProfilesForThreads(threadsState);

    if(!focusThreadId && threadsState.length){
      focusThreadId = threadsState[0].id;
    }
    activeThreadId = focusThreadId || null;

    renderThreads();
    renderChatHeader(threadsState.find(t=>t.id === activeThreadId) || null);

    if(activeThreadId){
      await loadMessages(activeThreadId);
    }
  }

  async function findOrCreateThreadWithSeller(sellerId){
    if(!currentUser || !sellerId) return null;
    if(sellerId === currentUser.id) return null;

    // Look for existing thread between buyer(currentUser) and seller(sellerId)
    const { data, error } = await supabaseClient
      .from("threads")
      .select("*")
      .or(
        `and(buyer_id.eq.${currentUser.id},seller_id.eq.${sellerId}),` +
        `and(buyer_id.eq.${sellerId},seller_id.eq.${currentUser.id})`
      )
      .order("created_at",{ ascending:false })
      .limit(1);

    if(!error && data && data.length){
      return data[0];
    }

    // Create a new thread treating current user as buyer, param as seller
    const nowIso = new Date().toISOString();
    const { data: created, error: insertErr } = await supabaseClient
      .from("threads")
      .insert({
        buyer_id: currentUser.id,
        seller_id: sellerId,
        created_at: nowIso,
        last_message_at: nowIso,
        last_message_text: null
      })
      .select()
      .single();

    if(insertErr){
      console.error("create thread error", insertErr);
      return null;
    }
    return created;
  }

  document.addEventListener("DOMContentLoaded", async ()=>{
    const session = await ensureSession();
    if(!session?.user){
      window.location.href = "auth.html";
      return;
    }
    currentUser = session.user;

    const params = new URLSearchParams(window.location.search);
    const sellerIdParam = params.get("user") || params.get("seller");

    let focusThreadId = null;
    if(sellerIdParam && sellerIdParam !== currentUser.id){
      const t = await findOrCreateThreadWithSeller(sellerIdParam);
      if(t) focusThreadId = t.id;
    }

    // Search filter
    const searchEl = document.getElementById("searchInput");
    if(searchEl){
      searchEl.addEventListener("input", ()=> renderThreads());
    }

    const sendBtn = document.getElementById("send");
    const msgInput = document.getElementById("msg");
    if(sendBtn){
      sendBtn.addEventListener("click", sendMessage);
    }
    if(msgInput){
      msgInput.addEventListener("keydown", e=>{
        if(e.key === "Enter" && !e.shiftKey){
          e.preventDefault();
          sendMessage();
        }
      });
    }

    await loadThreads({ focusThreadId });
  });
</script>

<script>
  window.HM && window.HM.renderShell({ currentPage: "messages" });
</script>

</body>
</html>
