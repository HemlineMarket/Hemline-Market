<!-- File: public/messages.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>Messages — Hemline Market</title>

  <!-- UNIVERSAL CSS STACK -->
  <link rel="stylesheet" href="styles/hm-modern.css"/>
  <link rel="stylesheet" href="styles/hm-header.css"/>
  <link rel="stylesheet" href="styles/hm-typography.css"/>
  <link rel="stylesheet" href="styles/hm-footer.css"/>

  <!-- Page-specific styles only -->
  <style>
    :root{
      --ink:#111827;
      --muted:#6b7280;
      --line:#e5e7eb;
      --bg:#fff;
      --accent:#991b1b;
      --bg-page:#fafafa;
      --thread-selected:#fef2f2;
    }

    html,body{
      margin:0;
      background:var(--bg-page);
      color:var(--ink);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
      -webkit-font-smoothing:antialiased;
      max-width:100%;
      overflow-x:hidden;
    }

    .wrap{
      max-width:1200px;
      margin:0 auto;
      padding:0 12px;
    }

    /* page */
    h1{
      margin:18px 0 12px;
      font-size:24px;
      font-weight:800;
    }

    .page{
      display:grid;
      grid-template-columns:320px 1fr;
      gap:16px;
      margin:16px 0;
    }

    .panel{
      background:#fff;
      border:1px solid var(--line);
      border-radius:12px;
      overflow:hidden;
    }

    .inbox{
      display:flex;
      flex-direction:column;
    }

    .search{
      padding:10px;
      border-bottom:1px solid var(--line);
    }

    .search input{
      width:100%;
      padding:10px;
      border:1px solid var(--line);
      border-radius:10px;
      font:inherit;
    }

    .threads{
      overflow:auto;
      max-height:calc(100vh - 220px);
    }

    .threads-empty{
      padding:16px;
      font-size:13px;
      color:var(--muted);
    }

    .thread{
      display:grid;
      grid-template-columns:auto 1fr auto;
      gap:10px;
      padding:12px;
      border-top:1px solid var(--line);
      cursor:pointer;
      background:#fff;
      transition:background .12s ease;
    }

    .thread:first-child{
      border-top:0;
    }

    .thread:hover{
      background:#f9fafb;
    }

    .thread.selected{
      background:var(--thread-selected);
    }

    .avatar{
      width:36px;
      height:36px;
      border-radius:50%;
      background:#eee;
      display:grid;
      place-items:center;
      font-weight:700;
      font-size:14px;
    }

    .meta{
      font-size:12px;
      color:var(--muted);
    }

    .title{
      font-weight:700;
      font-size:14px;
      margin-bottom:2px;
    }

    .pill{
      font-size:12px;
      border:1px solid var(--line);
      padding:2px 8px;
      border-radius:999px;
      color:#374151;
      align-self:flex-start;
      white-space:nowrap;
    }

    .pill.red{
      border-color:#fca5a5;
      color:#991b1b;
    }

    .chat{
      display:flex;
      flex-direction:column;
      height:calc(100vh - 220px);
    }

    .chat-header{
      padding:14px 16px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      gap:10px;
    }

    .chat-header-title{
      font-weight:700;
      font-size:15px;
    }

    .chat-header-meta{
      font-size:12px;
      color:var(--muted);
    }

    .chat-scroll{
      flex:1;
      overflow:auto;
      padding:12px 16px;
      display:grid;
      gap:10px;
      background:#fcfcfc;
    }

    .bubble{
      max-width:70%;
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:12px;
      background:#fff;
      font-size:14px;
    }

    .bubble.me{
      justify-self:end;
      background:#fef2f2;
      border-color:#fca5a5;
    }

    .stamp{
      font-size:12px;
      color:var(--muted);
      justify-self:center;
    }

    .chat-empty{
      margin-top:40px;
      text-align:center;
      font-size:14px;
      color:var(--muted);
    }

    .composer{
      border-top:1px solid var(--line);
      padding:10px;
      display:flex;
      gap:8px;
      background:#fff;
    }

    .composer textarea{
      flex:1;
      min-height:42px;
      max-height:120px;
      padding:10px;
      border:1px solid var(--line);
      border-radius:10px;
      resize:vertical;
      font:inherit;
    }

    .composer button{
      background:var(--accent);
      color:#fff;
      border:0;
      border-radius:10px;
      padding:10px 14px;
      font-weight:700;
      cursor:pointer;
      font:inherit;
      white-space:nowrap;
    }

    .composer button:disabled,
    .composer textarea:disabled{
      opacity:.5;
      cursor:default;
    }

    /* mobile */
    @media (max-width:900px){
      .page{
        grid-template-columns:1fr;
      }
      .chat{
        height:auto;
      }
      .threads{
        max-height:none;
      }
    }
  </style>
</head>
<body>

<!-- UNIVERSAL HEADER -->
<div id="hm-shell-header"></div>

<!-- MAIN -->
<main class="wrap" id="maincontent">
  <h1>Messages</h1>

  <div class="page">
    <!-- Inbox -->
    <section class="panel inbox" aria-label="Inbox">
      <div class="search">
        <input id="searchInput" placeholder="Search messages…"/>
      </div>
      <div id="threadsEmpty" class="threads-empty">
        No conversations match your search.
      </div>
      <div class="threads" id="threadsList"></div>
    </section>

    <!-- Chat -->
    <section class="panel chat" aria-label="Conversation">
      <div class="chat-header">
        <div class="avatar" id="chatAvatar">?</div>
        <div>
          <div class="chat-header-title" id="chatName">Select a conversation</div>
          <div class="chat-header-meta" id="chatMeta">
            Choose a thread on the left to view messages.
          </div>
        </div>
      </div>
      <div class="chat-scroll" id="chat">
        <div class="chat-empty" id="chatEmpty">
          No conversation selected.
        </div>
      </div>
      <div class="composer">
        <textarea id="msg" placeholder="Write a reply…" disabled></textarea>
        <button id="send" disabled>Send</button>
      </div>
    </section>
  </div>
</main>

<!-- UNIVERSAL FOOTER -->
<div id="hm-shell-footer"></div>

<!-- JS STACK -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="scripts/hm-shell.js"></script>

<script>
  // --- Supabase + messaging logic ---
  const supabase = window.supabase.createClient(
    "https://clkizksbvxjkoatdajgd.supabase.co",
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNsa2l6a3Nidnhqa29hdGRhamdkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ2ODAyMDUsImV4cCI6MjA3MDI1NjIwNX0.m3wd6UAuqxa7BpcQof9mmzd8zdsmadwGDO0x7-nyBjI",
    { auth:{ persistSession:true, autoRefreshToken:true, detectSessionInUrl:true } }
  );

  const els = {
    threadsList: document.getElementById("threadsList"),
    threadsEmpty: document.getElementById("threadsEmpty"),
    searchInput: document.getElementById("searchInput"),
    chat: document.getElementById("chat"),
    chatEmpty: document.getElementById("chatEmpty"),
    chatAvatar: document.getElementById("chatAvatar"),
    chatName: document.getElementById("chatName"),
    chatMeta: document.getElementById("chatMeta"),
    msgInput: document.getElementById("msg"),
    sendBtn: document.getElementById("send")
  };

  let currentUser = null;
  let currentThreadId = null;
  let allThreads = [];        // raw thread rows
  let profileById = {};       // { userId: profile }
  let otherUserIdByThread = {}; // { threadId: otherUserId }

  function initialsFromName(first, last, email){
    if(first && last) return (first[0] + last[0]).toUpperCase();
    if(first) return (first[0] + (first[1] || "")).toUpperCase();
    if(email) return email[0].toUpperCase();
    return "?";
  }

  function formatRelative(ts){
    if(!ts) return "";
    const d = new Date(ts);
    const now = new Date();
    const diffMs = now - d;
    const diffDays = diffMs / (1000*60*60*24);
    if(diffDays < 1){
      return "Today";
    }else if(diffDays < 2){
      return "Yesterday";
    }
    return d.toLocaleDateString();
  }

  async function ensureSession(maxWaitMs=3000){
    let { data:{ session } } = await supabase.auth.getSession();
    if(session?.user) return session;
    const start = Date.now();
    while(!session?.user && Date.now() - start < maxWaitMs){
      await new Promise(r=>setTimeout(r,120));
      ({ data:{ session } } = await supabase.auth.getSession());
    }
    return session;
  }

  async function fetchProfiles(ids){
    const uniq = Array.from(new Set(ids.filter(Boolean)));
    if(!uniq.length) return {};
    const { data, error } = await supabase
      .from("profiles")
      .select("*")
      .in("id", uniq);
    if(error){
      console.error("Profile fetch error", error);
      return {};
    }
    const map = {};
    data.forEach(p => { map[p.id] = p; });
    return map;
  }

  function renderThreads(filterText=""){
    const list = els.threadsList;
    const empty = els.threadsEmpty;
    list.innerHTML = "";

    const q = (filterText || "").trim().toLowerCase();

    const filtered = allThreads.filter(t => {
      const otherId = otherUserIdByThread[t.id];
      const prof = profileById[otherId] || {};
      const name = (prof.first_name || "") + " " + (prof.last_name || "");
      const store = prof.store_name || "";
      const preview = t.last_message_preview || "";
      const haystack = (name + " " + store + " " + preview).toLowerCase();
      return !q || haystack.includes(q);
    });

    if(!filtered.length){
      empty.style.display = "block";
      return;
    }

    empty.style.display = "none";

    filtered.forEach(t => {
      const otherId = otherUserIdByThread[t.id];
      const prof = profileById[otherId] || {};
      const name = ((prof.first_name || "") + " " + (prof.last_name || "")).trim() || (prof.store_name || "Hemline member");
      const avatarInitials = initialsFromName(prof.first_name, prof.last_name, prof.email);
      const preview = t.last_message_preview || (t.message_count ? "(No preview)" : "(No messages yet)");
      const when = formatRelative(t.last_message_at || t.updated_at || t.created_at);

      const row = document.createElement("button");
      row.type = "button";
      row.className = "thread";
      row.dataset.threadId = t.id;

      if(t.id === currentThreadId){
        row.classList.add("selected");
      }

      row.innerHTML = `
        <div class="avatar">${avatarInitials}</div>
        <div>
          <div class="title">${name}</div>
          <div class="meta">${preview}</div>
        </div>
        <div class="pill">${when || ""}</div>
      `;

      row.addEventListener("click", () => openThread(t.id));

      list.appendChild(row);
    });
  }

  function setComposerEnabled(enabled){
    els.msgInput.disabled = !enabled;
    els.sendBtn.disabled = !enabled;
  }

  function renderEmptyChat(){
    els.chat.innerHTML = "";
    const empty = document.createElement("div");
    empty.className = "chat-empty";
    empty.textContent = "No messages yet. Send the first message.";
    els.chat.appendChild(empty);
  }

  async function openThread(threadId){
    currentThreadId = threadId;
    renderThreads(els.searchInput.value);

    const otherId = otherUserIdByThread[threadId];
    const prof = profileById[otherId] || {};
    const name = ((prof.first_name || "") + " " + (prof.last_name || "")).trim() || (prof.store_name || "Hemline member");
    const avatarInitials = initialsFromName(prof.first_name, prof.last_name, prof.email);

    els.chatAvatar.textContent = avatarInitials;
    els.chatName.textContent = name;
    els.chatMeta.textContent = prof.store_name ? prof.store_name : "Updated conversation";

    setComposerEnabled(true);
    els.msgInput.placeholder = "Write a reply…";

    // Load messages
    els.chat.innerHTML = "";
    const { data, error } = await supabase
      .from("messages")
      .select("*")
      .eq("thread_id", threadId)
      .order("created_at", { ascending:true });

    if(error){
      console.error("Messages fetch error", error);
      const errDiv = document.createElement("div");
      errDiv.className = "chat-empty";
      errDiv.textContent = "We couldn’t load messages. Please refresh.";
      els.chat.appendChild(errDiv);
      return;
    }

    if(!data.length){
      renderEmptyChat();
      return;
    }

    data.forEach(msg => {
      const bubble = document.createElement("div");
      bubble.className = "bubble" + (msg.sender_id === currentUser.id ? " me" : "");
      bubble.textContent = msg.body || "";
      els.chat.appendChild(bubble);
    });

    const last = data[data.length - 1];
    const stamp = document.createElement("div");
    stamp.className = "stamp";
    stamp.textContent = new Date(last.created_at).toLocaleString();
    els.chat.appendChild(stamp);

    els.chat.scrollTop = els.chat.scrollHeight;
  }

  function getOtherUserIdForThread(thread){
    if(!thread || !currentUser) return null;
    if(thread.user_a === currentUser.id) return thread.user_b;
    if(thread.user_b === currentUser.id) return thread.user_a;
    return null;
  }

  async function ensureThreadWithUser(otherUserId){
    if(!currentUser || !otherUserId || currentUser.id === otherUserId) return null;

    // Try to find existing thread in DB
    const { data: existing, error } = await supabase
      .from("message_threads")
      .select("*")
      .or(
        `and(user_a.eq.${currentUser.id},user_b.eq.${otherUserId}),` +
        `and(user_a.eq.${otherUserId},user_b.eq.${currentUser.id})`
      )
      .maybeSingle();

    if(existing){
      return existing.id;
    }

    // Create new thread
    const { data: created, error: insErr } = await supabase
      .from("message_threads")
      .insert({
        user_a: currentUser.id,
        user_b: otherUserId
      })
      .select("*")
      .single();

    if(insErr){
      console.error("Create thread error", insErr);
      return null;
    }

    // Push into local arrays so we don't need a full reload
    allThreads.unshift(created);
    otherUserIdByThread[created.id] = getOtherUserIdForThread(created);
    return created.id;
  }

  async function loadThreads(initialThreadId){
    const { data, error } = await supabase
      .from("message_threads")
      .select("*")
      .or(`user_a.eq.${currentUser.id},user_b.eq.${currentUser.id}`)
      .order("updated_at", { ascending:false });

    if(error){
      console.error("thread list error", error);
      els.threadsEmpty.style.display = "block";
      els.threadsEmpty.textContent = "We couldn’t load your conversations.";
      return;
    }

    allThreads = data || [];
    otherUserIdByThread = {};
    const profileIds = [];

    allThreads.forEach(t => {
      const otherId = getOtherUserIdForThread(t);
      otherUserIdByThread[t.id] = otherId;
      if(otherId) profileIds.push(otherId);
    });

    profileById = await fetchProfiles(profileIds);

    renderThreads();

    if(initialThreadId && allThreads.some(t => t.id === initialThreadId)){
      openThread(initialThreadId);
    }
  }

  async function sendMessage(){
    const text = (els.msgInput.value || "").trim();
    if(!text || !currentThreadId || !currentUser) return;

    els.msgInput.value = "";
    els.msgInput.focus();

    // Insert message
    const { data: inserted, error } = await supabase
      .from("messages")
      .insert({
        thread_id: currentThreadId,
        sender_id: currentUser.id,
        body: text
      })
      .select("*")
      .single();

    if(error){
      console.error("send message error", error);
      return;
    }

    // Optimistically append to UI
    if(els.chat.querySelector(".chat-empty")){
      els.chat.innerHTML = "";
    }
    const bubble = document.createElement("div");
    bubble.className = "bubble me";
    bubble.textContent = text;
    els.chat.appendChild(bubble);

    const stamp = document.createElement("div");
    stamp.className = "stamp";
    stamp.textContent = new Date(inserted.created_at).toLocaleString();
    els.chat.appendChild(stamp);

    els.chat.scrollTop = els.chat.scrollHeight;

    // Update thread metadata + insert notification for the other user
    const preview = text.slice(0, 140);
    const otherId = otherUserIdByThread[currentThreadId];

    const updates = [
      supabase
        .from("message_threads")
        .update({
          last_message_at: inserted.created_at,
          last_message_preview: preview
        })
        .eq("id", currentThreadId)
    ];

    if(otherId){
      updates.push(
        supabase
          .from("notifications")
          .insert({
            user_id: otherId,
            kind: "message",
            title: "New message",
            body: preview,
            message_thread_id: currentThreadId,
            message_id: inserted.id
          })
      );
    }

    Promise.all(updates).catch(err => console.error("post-send updates error", err));

    // Refresh thread list so preview + date update
    loadThreads(currentThreadId);
  }

  async function initMessagesPage(){
    const session = await ensureSession();
    if(!session || !session.user){
      window.location.href = "auth.html";
      return;
    }
    currentUser = session.user;

    // URL params: ?u=<otherUserId> or ?thread=<threadId>
    const params = new URLSearchParams(window.location.search);
    const otherUserId = params.get("u");
    const threadParam = params.get("thread");
    let initialThreadId = threadParam;

    if(otherUserId && !initialThreadId){
      initialThreadId = await ensureThreadWithUser(otherUserId);
    }

    await loadThreads(initialThreadId);

    // Events
    els.sendBtn.addEventListener("click", sendMessage);
    els.msgInput.addEventListener("keydown", e => {
      if(e.key === "Enter" && !e.shiftKey){
        e.preventDefault();
        sendMessage();
      }
    });

    els.searchInput.addEventListener("input", () => {
      renderThreads(els.searchInput.value);
    });
  }

  initMessagesPage();
</script>

<script>
  window.HM && window.HM.renderShell({ currentPage: "messages" });
</script>

</body>
</html>
